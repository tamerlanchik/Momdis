function y=Area_2J;
load data_flag_nd;
load data_x0;
load data_r_q;
load data_qmm;
load data_r_set;

% не нужно t0 T 
max_r_q=[8,8];
eps=0.01;
% Построение векторов согласно максимальному числу параметров каждой коалиции max_r_q
r_set1=zeros(1,max_r_q(1)); r_set1(1,1:r_q(1))=r_set(1,1:r_q(1));
r_set2=zeros(1,max_r_q(2)); r_set2(1,1:r_q(2))=r_set(1,(r_q(1)+1):(r_q(1)+r_q(2)));
q_min1=zeros(1,max_r_q(1)); q_min1(1,1:r_q(1))=q_min(1,1:r_q(1));
q_min2=zeros(1,max_r_q(2)); q_min2(1,1:r_q(2))=q_min(1,(r_q(1)+1):(r_q(1)+r_q(2)));
q_max1=zeros(1,max_r_q(1)); q_max1(1,1:r_q(1))=q_max(1,1:r_q(1));
q_max2=zeros(1,max_r_q(2)); q_max2(1,1:r_q(2))=q_max(1,(r_q(1)+1):(r_q(1)+r_q(2)));
h_q1=(q_max1-q_min1)./(r_set1-1); for i=1:size(h_q1,2); if h_q1(1,i)==0; h_q1(1,i)=1; end; end;
h_q2=(q_max2-q_min2)./(r_set2-1); for i=1:size(h_q2,2); if h_q2(1,i)==0; h_q2(1,i)=1; end; end;

% Основной этап - циклы по каждому из параметров, начиная с последних в массиве 8х8
i=0; tic;
for q18=q_min1(8):h_q1(8):q_max1(8);
for q17=q_min1(7):h_q1(7):q_max1(7);
for q16=q_min1(6):h_q1(6):q_max1(6);
for q15=q_min1(5):h_q1(5):q_max1(5);
for q14=q_min1(4):h_q1(4):q_max1(4);
for q13=q_min1(3):h_q1(3):q_max1(3);
for q12=q_min1(2):h_q1(2):q_max1(2);
for q11=q_min1(1):h_q1(1):q_max1(1);
   i=i+1; j=0;
   for q28=q_min2(8):h_q2(8):q_max2(8);
   for q27=q_min2(7):h_q2(7):q_max2(7);
   for q26=q_min2(6):h_q2(6):q_max2(6);
   for q25=q_min2(5):h_q2(5):q_max2(5);
   for q24=q_min2(4):h_q2(4):q_max2(4);
   for q23=q_min2(3):h_q2(3):q_max2(3);
   for q22=q_min2(2):h_q2(2):q_max2(2);
   for q21=q_min2(1):h_q2(1):q_max2(1);
       j=j+1;
       q_1=[q11,q12,q13,q14,q15,q16,q17,q18];
       q_2=[q21,q22,q23,q24,q25,q26,q27,q28];
       q=[q_1(1,1:r_q(1)),q_2(1,1:r_q(2))];
       x=mat_int(q,x0);
       J=mat_fun(x,q,0);
       Data.Q(i,j,:)=q; Data.J(i,j,:)=J; 
       set(findobj(RassOblPok, 'Tag', 'textVObPok') , 'String', num2str([i,j]));
%      [i,j]
   end;
   end;
   end;
   end;
   end;
   end;
   end;
   end;
end;
end;
end;
end;
end;
end;
end;
end;
Data.Time=toc; % Время расчета (в принципе, оно не особо нужно...)
% Построение области значений показателей и запись матрицы в mat-файл
DataM=Data;
save data_field DataM;

% Здесь (и только здесь) используется переменная с индексом "М". Это нужно для того,
% чтобы в процессе расчета областей равновесий не переинициализировывать (:-))
% данные по областям и они не пересекались по индексам обращения к ним.
% Далее в каждой сетевой процедуре используется вызов рассчитанной области показателей.
% Реализован вариант (см. сами функции), когда можно будет выбирать, по какой области
% осуществлять расчет того или иного вида равновесия (в том числе и несимметричного)
% (как пример, расчет Парето-границы: либо по всей области, либо только на множестве УКУ-решений).
% При реализации данный комментарий вполне можно удалить (он дан только для пояснения)

% В функциях имеет место следующее обозначение областей:
% Data1, Data2 - несимметричные области (для каждой стороны; их можно и не строить,
% но на всякий случай они сохраняются);
% Data0 - симметричный тип равновесия (пересечение несимметричных Data1 и Data2).
